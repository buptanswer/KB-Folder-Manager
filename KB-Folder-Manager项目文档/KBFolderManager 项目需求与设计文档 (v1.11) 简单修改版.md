# **KB Folder Manager（Windows / Python）项目需求与设计文档 (v1.11 \- User Intent Refined)**

## **0\. 背景与目标**

现在有一份 **完整文件夹（complete folder）** ，里面既包含“可被 AI 知识库解析的文件类型（文档/内容类）”，也包含“资源/其他类型文件（附件/素材/杂项）”。用户希望：

1. 把完整文件夹拆成两个结构完全一致的新文件夹 ：  
   * 一个只存“指定类型”的文件（简称： **文档文件夹 doc folder** ）  
   * 一个只存“其他类型”的文件（简称： **资源文件夹 res folder** ）  
   * 拆分过程中移到另一边的文件用占位符替换，占位符默认是名称为“文件名+拓展名+指定后缀”的空文件夹（选项1），后期也可以通过配置文件改成名称为“文件名+拓展名+指定后缀”的无后缀空文件（选项2），另外，命名里的“指定后缀”也应当可通过配置文件配置

2. 能把 doc folder 与 res folder 重新合并（merge）回一个完整文件夹（complete folder），要求结构一致、占位符被真实文件替换，从而用户能拿到最初的完整文件夹（complete folder）。

3. 能够对任意文件夹（包括子文件夹）的内容结构**建立索引（文件树+元数据+哈希）** ，用于后续的对比、同步、合并等。 

4. 能 **验证正确性** ，

   - 能验证完整文件夹（complete folder）、文档文件夹（doc folder）、资源文件夹（res folder）三者自身的合理性
     - 完整文件夹的自身验证主要是一类自身验证：用于拆分之前检查文件夹是否符合拆分的基本要求，也就是不能有无后缀空文件
     
       如大小写冲突、路径过长、**发现非法文件名**、**发现类似占位符的目录**
     
       1. **大小写冲突预检（v1.1 新增）**：  
          * 遍历目录时，使用 casefold() 检测同一层级是否存在仅大小写不同的文件名（如 a.txt 和 A.txt）。  
          * 若发现冲突：**FATAL 报错**，输出冲突清单，要求用户手动处理（防止在 Windows 默认环境下发生隐式覆盖）。  
       2. **符号链接/重解析点检查（v1.4 安全 / v1.7 越界保护）**：  
          * 正常人的个人知识库文件夹里怎么会有这种东西，直接改成如果有“ symlink 或 junction或者ink”直接在一类自身合理性检验里报错让用户自己解决就行了（比如直接删掉）
       3. 路径过长
       4. 发现非法文件名
       5. 发现类似占位符的目录或文件
          - 名称以“指定后缀”结尾的空文件夹和无后缀空文件是占位符的保留项目，不允许在即将进行拆分的完整文件夹里已经存在
     
     - 文档文件夹的自身验证主要是用于
       1. 一类自身验证：用于合并之前检查文件夹是否符合合并的基本要求
          - 如大小写冲突、路径过长、**发现非法文件名**
          - **大小写冲突预检（v1.1 新增）**：  
            * 遍历目录时，使用 casefold() 检测同一层级是否存在仅大小写不同的文件名（如 a.txt 和 A.txt）。  
            * 若发现冲突：**FATAL 报错**，输出冲突清单，要求用户手动处理（防止在 Windows 默认环境下发生隐式覆盖）。  
          - **符号链接/重解析点检查（v1.4 安全 / v1.7 越界保护）**：  
            * 正常人的个人知识库文件夹里怎么会有这种东西，直接改成如果有“ symlink 或 junction或者ink”直接在一类自身合理性检验里报错让用户自己解决就行了（比如直接删掉）
          - 路径过长
          - 发现非法文件名
       2. 二类自身验证：此时检验自身是否有“其他类型”的文件。
          - 若用于拆分之后的自身验证，有“其他类型”的文件，这可能说明拆分过程有问题，需要检查拆分过程的代码与逻辑。
          - 若用于合并之前的自身验证，有“其他类型”的文件，这可能说明用户在使用工具正确拆分后又手动添加了其他类型的文件，这种情况需要提醒用户手动处理
       
     - 资源文件夹的自身验证主要是用于
       1. 一类自身验证：用于合并之前检查文件夹是否符合合并的基本要求
          - 如大小写冲突、路径过长、**发现非法文件名**
          - **大小写冲突预检（v1.1 新增）**：  
            * 遍历目录时，使用 casefold() 检测同一层级是否存在仅大小写不同的文件名（如 a.txt 和 A.txt）。  
            * 若发现冲突：**FATAL 报错**，输出冲突清单，要求用户手动处理（防止在 Windows 默认环境下发生隐式覆盖）。  
          - **符号链接/重解析点检查（v1.4 安全 / v1.7 越界保护）**：  
            * 正常人的个人知识库文件夹里怎么会有这种东西，直接改成如果有“ symlink 或 junction或者ink”直接在一类自身合理性检验里报错让用户自己解决就行了（比如直接删掉）
          - 路径过长
          - 发现非法文件名
       2. 二类自身验证：此时检验自身是否有“指定类型”的文件。
          - 若用于拆分之后的自身验证，有“指定类型”的文件，这可能说明拆分过程有问题，需要检查拆分过程的代码与逻辑。
          - 若用于合并之前的自身验证，有“指定类型”的文件，这可能说明用户在使用工具正确拆分后又手动添加了其他类型的文件，这种情况需要提醒用户手动处理
     
   - 能验证完整文件夹（complete folder）、文档文件夹（doc folder）、资源文件夹（res folder）三者匹配（默认用户此时输入的只要是同名文件夹就是匹配的）时的相互合理性

     - 对于匹配的两个同名的同类型文件夹（比如都是文档文件夹或都是完整文件夹，但是一个新一个旧），需要满足：

       通过对比两者的索引（文件树+元数据+哈希）：

       1. 如果输入的新文件夹新增了某些东西，那说明用户可能在这期间添加了这个文件，需要用户手动处理
       2. 如果输入的新文件夹修改了某些东西，也就是同名的文件但哈希值不同，那说明用户可能在这期间修改了这个文件，需要用户手动处理
       3. 如果输入的新文件夹缺失了某些东西，那说明用户可能在这期间删除了这个文件西，需要用户手动处理
   
     - 对于匹配的两个同名的完整文件夹和文档文件夹，需要满足：
   
       完整文件夹通过工具正确拆分后得到的文档文件夹与输入的文档文件夹的内容完全一致，也就是两者是匹配的两个同名的同类型文件夹（符合上一条检验的规则）
   
     - 对于匹配的两个同名的完整文件夹和资源文件夹，需要满足：
   
       完整文件夹通过工具正确拆分后得到的资源文件夹与输入的资源文件夹的内容完全一致，也就是两者是匹配的两个同名的同类型文件夹（符合上一条检验的规则）
   
     - 对于匹配的两个同名的文档文件夹和资源文件夹，需要满足：
   
       两者完全互补（一边的文件一定对应一个另一边对应的占位符，比如名称为“文件名+拓展名+指定后缀”的空文件夹），除了互补的文件与占位符之外的文件夹结构完全相同
   
       1. 如果有文件在另一边找不到对应的正确的占位符，需要用户手动处理
       2. 如果有占位符在另一边找不到对应的正确的文件，需要用户手动处理
       3. 如果有文件夹结构不同，需要用户手动处理（如果占位符是指定名称的空文件夹，那么作为占位符的空文件夹除外）
   
   - 能验证文件夹符合进行拆分过程的前提条件：
   
     对于指定的完整文件夹（complete folder），需要满足：
   
     1. 完整文件夹能通过一类自身合理性检验（详见验证正确性的第一条）
   
   - 能验证拆分过程的正确性：
   
     对于三个匹配的文件夹：完整文件夹（complete folder）、文档文件夹（doc folder）、资源文件夹（res folder），需要满足：
   
     1. 文档文件夹和资源文件夹能通过二类自身合理性检验（详见验证正确性的第一条）
     2. 文档文件夹和资源文件夹能通过相互合理性检验（详见验证正确性的第二条）
   
   - 能验证文件夹符合进行合并过程的前提条件：
   
     对于指定的文档文件夹（doc folder）和资源文件夹（res folder），需要满足：
   
     1. 文档文件夹和资源文件夹能通过二类自身合理性检验（详见验证正确性的第一条）
     2. 文档文件夹和资源文件夹能通过相互合理性检验（详见验证正确性的第二条）
     3. 文档文件夹和资源文件夹能通过一类自身合理性检验（详见验证正确性的第一条）
   
   - 能验证合并过程的正确性：
   
     对于三个匹配的文件夹：完整文件夹（complete folder）、文档文件夹（doc folder）、资源文件夹（res folder），需要满足：
   
     完整文件夹再拆分成新的文档文件夹和新的资源文件夹后：
   
     1. 新文档文件夹与源文档文件夹能通过相互合理性检验（详见验证正确性的第二条）
     2. 新资源文件夹与源资源文件夹能通过相互合理性检验（详见验证正确性的第二条）

### **关键安全要求（强约束）**

* **“我的文件很重要”**： **任何操作过程都不允许修改原文件夹（只读、只复制 ），操作过程中输出的文件、文件夹和日志要输出到输出文件夹里按条理排好**。  
  
  * 拆分时，
  
    1. 用户输入完整文件夹路径、输出文件夹路径
    2. 程序首先对输入进行拆分前置检验，这一过程会首先输出完整文件夹的索引到输出文件夹根目录下的\index\complete
    3. 经过校验后若有问题，把问题（提醒用户要修改的地方）以及日志输出到输出文件夹根目录下的\logs\Split_pre_check，方便用户根据信息修改问题
    4. 用户修改后会再次手动运行拆分程序，输入完整文件夹路径、输出文件夹路径
    5. 此时首先更新\index\complete索引
    6. 经过程序校验后无问题，更新日志\logs\Split_pre_check，询问用户是否开始拆分
    7. 用户确认开始拆分，进行拆分过程，将拆分得到的文件文件夹输出到输出根目录下的\doc\文件夹名，拆分过程中顺便建立索引，索引输出到\index\doc；资源文件夹输出到输出根目录下的\res\文件夹名，拆分过程中顺便建立索引，索引输出到\index\res
    8. 将拆分过程中遇到的问题与日志写到\logs\Split
    9. 进行拆分正确性检验，过程中输出问题和日志文件：
       1. 文档文件夹的二类自身合理性检验：\logs\Split_done_check\doc
       2. 资源文件夹的二类自身合理性检验：\logs\Split_done_check\res
       3. 文档文件夹和资源文件夹的相互合理性检验：\logs\Split_done_check\doc_res
  
  * 合并时，
  
    1. 用户输入匹配的文件文件夹路径和资源文件夹路径，以及输出文件夹路径
  
    2. 程序首先对输入进行合并前置检验，这一过程会首先输出文件文件夹和资源文件夹的索引到输出文件夹根目录下的\index\doc和\index\res
  
    3. 经过校验后若有问题，把问题（提醒用户要修改的地方）以及日志输出到输出文件夹根目录下的\logs\Merge_pre_check，方便用户根据信息修改问题（合并预检验的三个步骤要分别写日志：
  
       1. 文档文件夹的二类自身合理性检验：\logs\Merge_pre_check\doc_B
       2. 资源文件夹的二类自身合理性检验：\logs\Merge_pre_check\res_B
       3. 文档文件夹和资源文件夹的相互合理性检验：\logs\Merge_pre_check\doc_res
       4. 文档文件夹的一类自身合理性检验：\logs\Merge_pre_check\doc_A
       5. 资源文件夹的一类自身合理性检验：\logs\Merge_pre_check\res_A）
  
    4. 用户修改后会再次手动运行合并程序，输入完整文件夹路径、输出文件夹路径
  
    5. 此时首先更新\index\complete索引
  
    6. 经过程序校验后无问题，更新日志\logs\Merge_pre_check，询问用户是否开始合并
  
    7. 用户确认开始合并，进行合并过程，将合并得到的完整文件夹输出到输出根目录下的\complete\文件夹名，合并过程中顺便建立索引，索引输出到\index\complete
  
    8. 将合并过程中遇到的问题与日志写到\logs\Merge
  
    9. 进行合并正确性检验，输出的完整文件夹再拆分成新的文档文件夹和新的资源文件夹后：
  
       1. 新文档文件夹与源文档文件夹能通过相互合理性检验（详见验证正确性的第二条）
       2. 新资源文件夹与源资源文件夹能通过相互合理性检验（详见验证正确性的第二条）
  
       过程中输出问题和日志文件：
  
       1. 新文档文件夹和源文档文件夹的相互合理性检验：\logs\Merge_done_check\doc_doc
       2. 新资源文件夹和源资源文件夹的相互合理性检验：\logs\Merge_done_check\res_res
  
  用户可能会单独调用的其他功能的流程：
  
  - 对任意文件夹（包括子文件夹）的内容结构**建立索引（文件树+元数据+哈希）**
  
    1. 用户输入任意文件夹路径、输出文件夹路径
    2. 对任意文件夹进行建立索引的过程，将索引文件输出到输出文件夹的\index
    3. 日志文件输出到输出文件夹的\logs\index
  
  - 验证完整文件夹（complete folder）、文档文件夹（doc folder）、资源文件夹（res folder）三者自身的合理性
  
    流程懒得写了，与上述类似
  
  - 验证完整文件夹（complete folder）、文档文件夹（doc folder）、资源文件夹（res folder）三者匹配（默认用户此时输入的只要是同名文件夹就是匹配的）时的相互合理性
  
    流程懒得写了，与上述类似
  
  但是这样有一个问题啊，我们现在相当于是模块化编程，模块功能可以被用户单独调用（比如仅建立索引或者仅进行自身二类验证），这些模块功能也可以被程序内的其他功能作为模块在程序内调用，但是同一个模块，用户单独调用和其他模块程序内调用的具体流程和输出文件夹的路径结构可能会有细微差异，这种最好还是统一比较好吧。虽然好像只要能保证每次输出文件夹都是空文件夹并且在用户已经知道输出文件夹的路径结构是什么样的前提下好像没什么问题，但是也许统一了更好？
  
* **全程监控**：需要必要的日志、常规错误检测、常规异常处理。（不用完全完备，只需要一般情况下，用户正确按照程序员的想法去使用时，确实有可能会出现的情况能正常处理就行了，毕竟这是给初级程序员练手的项目）

* **占位符规范**：所有占位符命名时的后缀比如“(在百度网盘)必须是英文括号（格式统一），并且要求做成 **可修改的全局配置参数** （未来可改短或改成其他）。

## **1\. 名词与定义**

### **1.1 文件夹类型**

* **完整文件夹（complete folder）** ：原始输入文件夹，包含全部文件与目录结构。**严格只读**。  
* **文档文件夹（doc folder）** ：拆分输出之一， **只包含指定类型** 的真实文件；其他类型用占位符表示。除此之外目录结构与完整文件夹相同。
* **资源文件夹（res folder）** ：拆分输出之一， **只包含其他类型** 的真实文件；指定类型用占位符表示。除此之外目录结构与完整文件夹相同。

### **1.2 指定类型（specified types）**

“主要是可以被AI知识库解析的类型，文档之类”。

**配置净化规则（v1.1 新增）：** 在加载配置时，必须对类型列表进行“轻量净化”，防止配置脏数据导致分类错误：

1. **Strip**：去除首尾空格/引号（如 ' .yaml ' \-\> .yaml）。  
2. **Lower**：全部转小写。  
3. **补点**：若没有点（如 yaml），自动补齐为 .yaml。  
4. **校验**：若净化后仍非法（如空字符串、仅有一个点），记录 WARNING 日志并忽略该项。

**扩展名判定策略（v1.4 明确）：**

* **规则**：文件类型判定默认取 **最后一个后缀（last suffix）**。  
* **以点开头**：如 .env，视为扩展名为 .env。

**参考列表：**

{  
  '.pdf', '.doc', '.docx', '.xlsx', '.xls', '.ppt', '.pptx',  
  '.txt', '.xmind', '.asset',  
  '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.tif', '.svg',  
  '.md', '.markdown',  
  '.mp4', '.mkv', '.avi', '.mov', '.wmv', '.flv', '.rmvb', '.srt',  
  '.mp3', '.wav', '.flac', '.aac', '.ogg',  
  '.py', '.java', '.c', '.cpp', '.js', '.html', '.css', '.json', '.xml', '.yaml', '.sh', '.ino',  
  '.drawio', '.csv'  
}

### **1.3 占位符（placeholder）**

当某个文件被分配到“另一边文件夹”时，在当前文件夹中要建立一个“占位符”来保持结构一致。 **注意**：拆分过程中移到另一边的文件用占位符替换，占位符默认是名称为“文件名+拓展名+指定后缀”的空文件夹（选项1），后期也可以通过配置文件改成名称为“文件名+拓展名+指定后缀”的无后缀空文件（选项2），另外，命名里的“指定后缀”也应当可通过配置文件配置。

* **占位符命名规则（严格）**  
  placeholder\_name \= \<原文件名(不含扩展名)\> \+ \<.扩展名\> \+ \<placeholder\_tag\>  
  默认 placeholder\_tag \= "(在百度网盘)"（英文括号）  
  * 例：原文件 报告.pdf → 占位符文件夹 报告.pdf(在百度网盘)  
* **可疑占位符（suspicious）**  
  “如果是名称可疑的文件夹（比如以“(在百度网盘)”结尾，但是不严格满足…），标记为可疑，提醒用户手动检查”。

## **2\. 总体功能清单（3 大模块）**

### **模块 A：拆分（Split / Classify）**

**目标** ：把 complete folder 拆为 doc folder \+ res folder，两者内部结构与 complete folder 完全一致（除“缺失文件被占位符替代”）。

#### **A3. 拆分规则（核心）**

对 complete folder 进行递归遍历：

3. **文件与目录分发（v1.9 修复 \- 空目录保护）**：  
   * **目录处理**：遍历到任意目录节点时（无论其内部是否有文件），必须在 doc 与 res 两侧立即创建对应目录，并在索引中记录为 type: "dir"。这确保空目录结构不丢失。  
   * **文件处理**：  
     * **复制策略（v1.2 明确）**：复制真实文件时，**必须保留元数据**（至少 size/mtime；语义等同于 Python shutil.copy2），以保证后续 B4 校验时时间戳一致。  
     * 若文件扩展名 ∈ specified types：  
       * 真实文件复制到 doc folder。  
       * 在 res folder 创建占位符空文件夹。  
     * 若文件扩展名 ∉ specified types：  
       * 真实文件复制到 res folder。  
       * 在 doc folder 创建占位符空文件夹。  

### **模块 B：验证与检测（Validate / Index / Compare）**

**目标** ：对 complete/doc/res 的正确性做系统验证，并生成索引。

#### **B0. 索引文件（Index / Manifest）**

* **文件名**：.kb\_index.json（属于工具产物）  
* **版本控制（v1.4 新增）**：JSON 根节点增加 schema\_version: 1。  
* **排序规则（v1.6 新增）**：entries 列表必须按 logical\_path 升序排序，确保输出确定性。  
* **原子写入（v1.1 明确）**：写入索引时，必须先写入 .kb\_index.json.tmp，写入成功后执行 rename 替换。  
* **内容补全（v1.8 修复）**：entries 中应包含所有目录节点（包括空目录），并显式标记 type: "file" | "dir"。这将确保 Merge 时能重建空目录结构。  
* **存储位置（v1.6 明确）**：  
  * 这部分咱们不是说要全部写到输出文件夹里按逻辑排好吗，但是其实因为咱们工具要是不删掉之前的“工具产物”设定的话，每次工具运行都会自动忽略工具产物其实也行，这样还能让索引的路径更清晰明了，毕竟直接就在被创建索引的文件夹根目录下嘛，而且如果已经有索引，还可以向用户展示索引创建时间，让用户决定沿用已经有的索引还是创建全新索引。但是有一个问题就是这会在原文件目录下创建一个新文件夹，这与“**“我的文件很重要”**： **任何操作过程都不允许修改原文件夹（只读、只复制 ），操作过程中输出的文件、文件夹和日志要输出到输出文件夹里按条理排好**。”相违背，但是其实也无所谓，毕竟这一条本来就是为了保护源文件不被修改，但是这是创建一个新的文件夹，并且索引文件也不算太多，不会怎么污染源文件夹的，而且其他文件都没有被修改或删除，也还行。两种方案你觉得哪个更好？
* **Hash 算法（v1.3 锁死）**：  
  * 默认 **全量 SHA-256**。  
  * **策略**：优先尝试调用系统 7z 命令计算。  
  * **命令标准**：必须强制指定算法，防止 7z 版本差异导致计算出 CRC。  
    * 参考模板：7z h -scrcSHA256 -- "<file>"
  * **回退**：若无 7z，使用 Python hashlib 分块读取计算。

#### **B1 & B2. Doc / Res 自身合理性检查**

* **忽略工具产物（v1.3 新增）**：遍历时遇到 .kb\_ 开头的文件/目录，直接跳过，不判定为“类型违规”。  
* 检查内部文件类型是否纯净（doc 只有指定类型，res 只有其他类型）。  
* 检查占位符是否规范，非空占位符视为 **ERROR**（严重错误，因为这会破坏 merge 的确定性）。  
* 生成/更新 .kb\_index.json。

#### **B3. Complete Folder 自身合理性检查**

* **输入**：complete folder 路径。  
* **输出**：日志 \+ 索引文件（默认在外部）。  
* **检查项**：  
  * **占位符混淆风险（v1.2 强化）**：是否存在以占位符后缀结尾（或高度相似）的文件夹。若在 Split 阶段发现，直接 **FATAL 中断**（防混淆）；Validate 阶段报 **ERROR**。  
  * **Windows 保留/非法文件名检查（v1.5 新增）**：  
    * 检测保留字：CON, PRN, AUX, NUL, COM1-COM9, LPT1-LPT9。  
    * 检测非法末尾：文件名以空格或点结尾。  
    * 发现以上情况直接 **FATAL 中断**（避免后续 IO 错误）。  
  * **符号链接/重解析点（v1.4 / v1.7）**：发现即 FATAL（默认）。若开启跟随，必须校验真实路径越界问题（同 A3）。  
  * 检测文件名过长、深度过深。  
  * 检测大小写冲突。

#### **B4. 两两检验**

* **忽略工具产物（v1.4 补全）**：在生成对比集合或对齐 logical\_path 时，必须显式过滤掉 .kb\_\* 文件，不参与 Hash/Size/Mtime 对比。  
* **Complete vs Doc**：利用索引中的 logical\_path 对齐，忽略占位符差异，对比真实文件。  
  * **对比维度（v1.2 细化）**：Hash（SHA-256）、Size、Mtime。  
  * **判定标准**：  
    * Hash 不一致 → **ERROR**（内容变了）。  
    * Mtime 不一致但 Hash 一致 → **WARNING**（除非开启 strict 模式才报 ERROR）。  
* **Complete vs Res（v1.11 补全）**：  
  * 利用索引中的 logical\_path 对齐。  
  * **指定类型文件**：Complete 中的真实文件应对应 Res 中的占位符目录（命名需严格一致）。  
  * **其他类型文件**：Complete 中的真实文件应对应 Res 中的真实文件（需比对 Hash/Size/Mtime）。  
* **Doc vs Res（互补性）**：  
  * doc 的占位符 \= res 的真实文件。  
  * res 的占位符 \= doc 的真实文件。  
  * **Validate 时发现“占位符目录非空”**：直接 **ERROR**。

### **模块 C：合并（Merge / Rebuild）**

**目标** ：doc \+ res \-\> merged folder。

#### **C1. 合并前置校验（强制）**

1. doc 自检（B1）通过。  
2. res 自检（B2）通过。  
3. 互补性检验（B4）通过。  
* **安全兜底（v1.6 新增）**：若索引中存在任何标记为 copy\_failed 或 hash\_failed 的条目，默认 **拒绝合并**（视为校验未通过）。必须显式使用 \--allow-incomplete-merge 参数才允许合并，并记录 WARN。  
* 若基础校验失败，拒绝合并。

#### **C2. 合并规则**

1. **目标检查**：Merged 输出目录必须为空（参考 A2 规则）。  
2. **执行合并**：  
   * **清单来源（v1.4 明确）**：以 B4 互补性校验通过后的 logical\_path 集合（即 doc/res 索引的合集）作为唯一输入，**严禁再次遍历文件系统**，防止产生未校验的新文件。  
   * **结构重建（v1.8/v1.9 修复）**：必须先遍历索引中的 dir 类型条目，重建所有目录结构（含空目录）。  
     * **关键过滤（v1.9 补丁）**：重建目录时，**严禁创建**名称符合“占位符后缀”的目录，也**严禁创建**工具产物目录（.kb\_），仅重建真实内容目录。  
   * 对每个 logical\_path (file)，根据类型从 doc 或 res 复制真实文件。  
   * **忽略工具产物（v1.3 新增）**：严禁复制 .kb\_index.json 或其他 .kb\_ 文件到 merged 文件夹。  
   * **复制策略（v1.2 明确）**：**必须保留元数据**（等同 shutil.copy2），确保合并后的文件与原始文件尽可能一致。  
   * **所有占位符目录均不进入 merged 文件夹**。  
   * 若合并过程中发现目标位置已有文件（非预期冲突）：立即中断。

## **3\. 非功能需求（可靠性 / 安全 / 可用性）**

### **3.1 错误处理与中断策略（v1.1 细化）**

* **单文件复制/Hash失败**：  
  * 默认：**ERROR 并中断**（宁可不改也别瞎改）。  
  * 若开启 \--continue：跳过该文件，并在索引中标记 copy\_failed=true 或 hash\_failed=true，日志记录 ERROR。后续 Compare/Merge 时视该文件为缺失或损坏。  
* **Hash 校验失败**：同上，默认中断。

### **3.3 路径长度与网络路径支持**

* **长路径**：坚持使用 \\\\?\\ 前缀策略。  
* **UNC 网络路径（v1.1 新增）**：  
  * 若源/目标是网络共享 \\\\server\\share\\...，对应的长路径形式需要转换为 \\\\?\\UNC\\server\\share\\...。  
  * 程序需自动检测并处理这种前缀转换，否则长路径支持会在网络盘失效。

## **6\. 配置文件（config.yaml）更新版**

**命名统一说明（v1.5）：** 本节键名与 CLI 参数保持映射一致，避免歧义。

\# 指定类型  
specified\_types:  
  \- .pdf  
  \- .doc  
  \- 'yaml'  \# 自动净化为 .yaml  
  \# ...

\# 占位符后缀  
placeholder\_tag: "(在百度网盘)"

\# 路径与安全策略  
output\_safety\_check: true      \# 对应 CLI: 无直接 flag, 属默认行为  
write\_index\_to\_source: false   \# 对应 CLI: \--write-index-to-source  
case\_sensitivity\_check: true   \# 默认行为  
follow\_symlinks: false         \# 对应 CLI: \--follow-links

\# 运行策略  
continue\_on\_error: false       \# 对应 CLI: \--continue  
resume\_enabled: true           \# 对应 CLI: \--resume (或默认开启)  
verify\_fingerprint: true       \# resume 时校验文件指纹

\# 索引与 Hash  
index\_filename: ".kb\_index.json"  
hash\_algorithm: "sha256"  
prefer\_7z: true  
\# (v1.6 注：该模板为参考；实际以本机 7z 版本为准，但必须强制 SHA-256，并且解析时只接受 SHA-256 字段；失败则回退 hashlib)  
7z\_command\_template: '7z h \-scrcSHA256 \-- "{filepath}"'

## **9\. 关键边界情况与处理规则（补充）**

1. **工具产物隔离（v1.3/1.4）**：必须在所有遍历（os.walk / scandir）和对比逻辑中，显式过滤掉 .kb\_ 开头的文件/目录。  

2. **空目录检测（v1.3/v1.7）**：检查目录是否为空时，使用 any(scandir) 逻辑，确保能感知到隐藏文件。Resume 模式下有条件允许非空（见 A2.3）。  

3. **大小写/WSL 兼容**：Windows 下 a.txt 和 A.txt 在同一个文件夹是冲突的，必须遍历检测，发现即 FATAL。  

4. **符号链接（v1.4/v1.7）**：默认拒绝跟随符号链接；若跟随，必须校验越界。  

5. **元数据一致性**：Split 和 Merge 时的复制操作必须使用 copy2 语义保留 mtime。  

   * \***声明（v1.5）**：copy2 仅承诺保留修改时间和访问权限位。对于 Windows 的完整 ACL（用户所有者/审计）、创建时间（ctime）不保证完全一致。本项目仅对 size/mtime 负责。  

6. **占位符污染（v1.9）**：Merge 重建目录时必须显式过滤掉所有“占位符目录”和“工具产物目录”。  

7. **索引原子性**：.kb\_index.json 永远采用 写入 .tmp \-\> replace 的方式落盘。

   其实没必要做断点续传功能，只要保证意外出错后，再次运行能够更新产出的文件就行，或者添加一个清除缓存的功能（就连这个我也觉得会增加开发难度而没必要）

